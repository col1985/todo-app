# Stage 1: Build the Go application
# Use the official Go image as a base for building
# FROM golang:1.23-alpine AS builder
FROM registry.access.redhat.com/ubi9/go-toolset:1.23 AS builder

# Set the current working directory inside the container
WORKDIR /app

# Copy go.mod and go.sum files to download dependencies
# This step is optimized for Docker caching: if dependencies don't change,
# this layer won't be rebuilt.
COPY go.mod .
COPY go.sum .

# Download Go modules
# Use go mod download to download all dependencies
RUN go mod download

# Copy the rest of the application source code
# The . (dot) signifies copying everything from the current directory
# into the /app directory in the container.
COPY . .

# Build the Go application
# CGO_ENABLED=0 disables CGO, making the binary statically linked
# -ldflags="-s -w" reduces the size of the binary by stripping debug info
# -o todo-app specifies the output executable name
# ./... builds all packages in the current directory and its subdirectories
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
  go build -a -installsuffix cgo \
  -ldflags="-s -w" \
  -o todo-api ./main.go

# Stage 2: Create the final lean image
# Use a minimal base image for the final application (scratch is the smallest)
FROM registry.access.redhat.com/ubi9/go-toolset:1.23

# Set the current working directory
WORKDIR /

# Copy the built executable from the builder stage
# --from=builder specifies to copy from the stage named 'builder'
COPY --from=builder /app/todo-api .

# Expose the port the application will listen on
EXPOSE 8080

# Command to run the executable when the container starts
ENTRYPOINT ["./todo-api"]
